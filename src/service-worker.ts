/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// =====================================================
// NOTIFICATIONS PUSH POUR CALENDRCAR
// =====================================================

// Gestion des notifications push
self.addEventListener('push', (event) => {
  console.log('Push reçu:', event);
  
  const options = {
    body: 'Nouvelle notification de CalendrCar',
    icon: '/logo192.png',
    badge: '/favicon.ico',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    },
    actions: [
      {
        action: 'explore',
        title: 'Voir détails',
        icon: '/logo192.png'
      },
      {
        action: 'close',
        title: 'Fermer'
      }
    ],
    tag: 'calendrcar-notification',
    renotify: true,
    requireInteraction: true
  };

  if (event.data) {
    try {
      const payload = event.data.json();
      options.body = payload.body || options.body;
      options.data = { ...options.data, ...payload.data };
      
      // Types de notifications spécifiques
      if (payload.type === 'reservation-reminder') {
        options.body = `Rappel: ${payload.clientName} - ${payload.vehicleName}`;
        options.badge = '/favicon.ico';
        options.tag = 'reservation-reminder';
      } else if (payload.type === 'vehicle-maintenance') {
        options.body = `Maintenance requise: ${payload.vehicleName}`;
        options.badge = '/favicon.ico';
        options.tag = 'vehicle-maintenance';
      } else if (payload.type === 'new-reservation') {
        options.body = `Nouvelle réservation: ${payload.clientName}`;
        options.badge = '/favicon.ico';
        options.tag = 'new-reservation';
      }
    } catch (e) {
      console.error('Erreur parsing payload push:', e);
    }
  }

  event.waitUntil(
    self.registration.showNotification('CalendrCar', options)
  );
});

// Gestion des clics sur notifications
self.addEventListener('notificationclick', (event) => {
  console.log('Notification cliquée:', event);
  
  event.notification.close();
  
  const action = event.action;
  const data = event.notification.data;
  
  if (action === 'close') {
    return;
  }
  
  // Détermine l'URL à ouvrir selon le type de notification
  let urlToOpen = '/';
  
  if (data && data.type) {
    switch (data.type) {
      case 'reservation-reminder':
      case 'new-reservation':
        urlToOpen = '/?page=planning';
        break;
      case 'vehicle-maintenance':
        urlToOpen = '/?page=vehicles';
        break;
      default:
        urlToOpen = '/?page=dashboard';
    }
  }
  
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Cherche une fenêtre déjà ouverte
        for (const client of clientList) {
          if (client.url.includes(self.location.origin) && 'focus' in client) {
            return client.focus().then(() => {
              // Navigue vers la page appropriée
              return client.postMessage({
                type: 'NOTIFICATION_CLICK',
                url: urlToOpen,
                data: data
              });
            });
          }
        }
        
        // Ouvre une nouvelle fenêtre si aucune n'est trouvée
        if (clients.openWindow) {
          return clients.openWindow(urlToOpen);
        }
      })
  );
});

// Gestion de la fermeture des notifications
self.addEventListener('notificationclose', (event) => {
  console.log('Notification fermée:', event);
  
  // Analytiques ou nettoyage si nécessaire
  const data = event.notification.data;
  if (data && data.primaryKey) {
    // Marquer comme vue/fermée dans la base de données locale
    console.log('Notification fermée, ID:', data.primaryKey);
  }
});

// Synchronisation en arrière-plan
self.addEventListener('sync', (event) => {
  console.log('Background sync:', event);
  
  if (event.tag === 'calendrcar-sync') {
    event.waitUntil(
      // Synchronise les données locales avec le serveur
      syncCalendrCarData()
    );
  }
});

// Fonction de synchronisation des données
async function syncCalendrCarData() {
  try {
    console.log('Synchronisation des données CalendrCar...');
    
    // Récupère les données locales
    const cache = await caches.open('calendrcar-data');
    const reservationsResponse = await cache.match('/api/reservations');
    const vehiclesResponse = await cache.match('/api/vehicles');
    
    if (reservationsResponse && vehiclesResponse) {
      const reservations = await reservationsResponse.json();
      const vehicles = await vehiclesResponse.json();
      
      // Logique de synchronisation (placeholder pour future API)
      console.log('Données à synchroniser:', { reservations, vehicles });
      
      // Ici, on enverrait les données à un serveur distant
      // await fetch('/api/sync', { method: 'POST', body: JSON.stringify({reservations, vehicles}) });
    }
    
    return Promise.resolve();
  } catch (error) {
    console.error('Erreur lors de la synchronisation:', error);
    return Promise.reject(error);
  }
}

// Cache des données de l'application
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new StaleWhileRevalidate({
    cacheName: 'calendrcar-api',
    plugins: [
      new ExpirationPlugin({ 
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 // 24 heures
      }),
    ],
  })
);

// Cache des données localStorage
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CACHE_DATA') {
    const { key, data } = event.data;
    
    // Sauvegarde dans le cache du service worker
    caches.open('calendrcar-data').then(cache => {
      cache.put(`/storage/${key}`, new Response(JSON.stringify(data)));
    });
  }
});
